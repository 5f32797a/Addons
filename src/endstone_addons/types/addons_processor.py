import os
import ujson as json
import shutil
from zipfile import ZipFile, ZipInfo, is_zipfile, BadZipFile

from endstone.plugin import Plugin
from endstone_addons.tools.type_getter import get_pack_type
from endstone_addons.types.pack_type import PackType
from endstone_addons.tools.zip_processor import process_zip
from endstone_addons.types.path_provider import PathProvider

class AddonsProcessor:
    def process_addons(self, addons_paths: list, plugin: Plugin) -> dict:
        """
        Processes a list of addon paths, extracts their contents, and returns
        a map of which pack folders were created for each addon file.
        This now handles nested archives (e.g., .mcaddon containing .mcpacks)
        via the recursive zip_processor.

        Returns: A dict mapping addon_path -> [list_of_extracted_pack_folders]
        """
        processed_map = {}
        for path in addons_paths:
            filename = os.path.basename(path)
            loggable_filename = filename.encode('utf-8', 'replace').decode('utf-8')
            # Use the filename without extension as the base name for hashing
            base_name_for_hashing = os.path.splitext(filename)[0]
            plugin.logger.info(f"Processing '{loggable_filename}'...")

            if not is_zipfile(path):
                plugin.logger.warning(f"Skipping '{loggable_filename}' as it is not a valid zip archive.")
                continue

            try:
                with ZipFile(path, 'r') as zip_file:
                    extracted_packs_for_this_file = []
                    
                    # Define a callback function to be executed by process_zip for each manifest found
                    def extraction_callback(zip_info: ZipInfo, zf: ZipFile, p: Plugin, final_pack_name: str):
                        # Attempt to extract the pack contents using the provided manifest and zip file object
                        # The final_pack_name is the unique hashed name generated by zip_processor
                        if self.__extract_pack_contents(zip_info, zf, p, final_pack_name):
                            # If extraction is successful, record the name of the folder created
                            extracted_packs_for_this_file.append(final_pack_name)
                    
                    # The new `process_zip` is recursive and will find all manifests, even in nested zips.
                    process_zip(zip_file, extraction_callback, plugin, base_name_for_hashing)
                    
                    # After processing, if no packs were extracted, log a warning.
                    # This helps identify files that look like addons but contain nothing valid.
                    if not extracted_packs_for_this_file:
                         plugin.logger.warning(f"No valid packs were extracted from '{loggable_filename}'. It might be empty or have an unsupported structure.")

                    # Map the original addon file path to the list of unique pack folders it created
                    processed_map[path] = extracted_packs_for_this_file

                plugin.logger.info(f"Finished processing addon from '{loggable_filename}'.")

            except BadZipFile:
                plugin.logger.warning(f"Could not process '{loggable_filename}', it seems to be a corrupted zip file.")
            except Exception as e:
                plugin.logger.error(f"An unexpected error occurred while processing '{loggable_filename}': {e}")
        
        return processed_map

    def __extract_pack_contents(self, zip_info: ZipInfo, zip_file: ZipFile, plugin: Plugin, final_pack_name: str) -> bool:
        """
        Extracts a single pack's contents based on its manifest.
        The `final_pack_name` is the unique, hashed name for the output folder.
        Returns True on success, False on failure.
        """
        manifest_path_in_zip = zip_info.filename.replace("\\", "/")
        # The root folder of the pack's content within the zip file
        pack_content_root = os.path.dirname(manifest_path_in_zip)

        try:
            # This code reads the manifest, strips any line starting with '//', and then parses it.
            with zip_file.open(zip_info.filename) as manifest_file:
                try:
                    content_bytes = manifest_file.read()
                    content_string = content_bytes.decode('utf-8-sig')
                    lines = content_string.splitlines()
                    valid_lines = [line for line in lines if not line.strip().startswith('//')]
                    cleaned_content = "\n".join(valid_lines)
                    manifest = json.loads(cleaned_content)
                except (json.JSONDecodeError, UnicodeDecodeError) as e:
                    plugin.logger.error(f"Failed to decode manifest.json ('{manifest_path_in_zip}') in '{zip_file.filename}'. It may be corrupted. Error: {e}. Skipping this inner pack.")
                    return False

            pack_type = get_pack_type(manifest)
            if pack_type == PackType.Unknown:
                plugin.logger.warning(f"Unknown pack type for manifest '{manifest_path_in_zip}' in '{zip_file.filename}'. Skipping.")
                return False

            target_dir = PathProvider.behavior_packs() if pack_type == PackType.Bp else PathProvider.resource_packs()
            # The final path where the pack will be extracted, e.g., .../worlds/MyWorld/behavior_packs/MyAddon_a1b2c3d4
            final_pack_path = os.path.join(target_dir, final_pack_name)
            
            # Clean up any old version of this specific pack folder before extracting
            if os.path.isdir(final_pack_path):
                shutil.rmtree(final_pack_path)

            plugin.logger.info(f"Extracting {pack_type.name} to '{final_pack_name}'...")

            # Iterate through all members of the zip to find files belonging to this specific pack
            for member_info in zip_file.infolist():
                member_path = member_info.filename.replace("\\", "/")
                
                # Check if the member is within the pack's content root and is a file
                if not member_path.startswith(pack_content_root) or member_info.is_dir():
                    continue

                # Calculate the path relative to the pack's root to recreate the structure
                relative_path = os.path.relpath(member_path, pack_content_root)
                # Security check to prevent path traversal attacks (e.g., "../../../something")
                if relative_path.startswith('..'):
                    continue
                
                # Construct the full destination path for the file
                target_file_path = os.path.join(final_pack_path, relative_path)
                
                try:
                    # Create the necessary directories for the file
                    os.makedirs(os.path.dirname(target_file_path), exist_ok=True)
                    # Open the source file from the zip and write it to the destination
                    with zip_file.open(member_info) as source, open(target_file_path, "wb") as target_file:
                        shutil.copyfileobj(source, target_file)
                except OSError as e:
                    plugin.logger.error(f"Could not write file to '{target_file_path}'. Reason: {e}.")
                    continue # Continue to the next file
            
            # If we reach here, the extraction for this pack was successful
            return True

        except Exception as e:
             plugin.logger.error(f"An unexpected error occurred during content extraction for pack '{final_pack_name}': {e}")
             return False

# Create an instance of the class to be imported by other modules
addons_processor = AddonsProcessor()